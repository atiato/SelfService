/**
 * ANGULAR 2 LOCALIZATION
 * An Angular 2 library to translate messages, dates and numbers.
 * Written by Roberto Simonetti.
 * MIT license.
 * https://github.com/robisim74/angular2localization
 */
import { Injectable, EventEmitter, Output } from '@angular/core';
import { Http } from '@angular/http';
import { Observable } from 'rxjs/Observable';
import 'rxjs/add/operator/map';
import 'rxjs/add/observable/merge';
import { LocaleService } from './locale.service';
import { IntlSupport } from './Intl-support';
/**
 * LocalizationService class.
Gets the translation data and performs operations.

\@author Roberto Simonetti
 */
export var LocalizationService = (function () {
    /**
     * @param {?} http
     * @param {?} locale
     */
    function LocalizationService(http, locale) {
        var _this = this;
        this.http = http;
        this.locale = locale;
        /**
         * Output for event translation changed.
         */
        this.translationChanged = new EventEmitter(true);
        this.enableLocale = false;
        this.providers = [];
        this.translationData = {};
        this.composedKey = true;
        this.keySeparator = ".";
        this.languageCode = "";
        // Initializes the loading mode.
        this.loadingMode = LoadingMode.Direct;
        // Initializes the service state.
        this.serviceState = ServiceState.isWaiting;
        // When the language changes, subscribes to the event & call updateTranslation method.
        this.locale.updateLocalization.subscribe(
        // Generator or next.
        function () { return _this.updateTranslation(); });
    }
    /**
     * Direct loading: adds new translation data.
    
    \@param language The two-letter code of the language for the translation data
    \@param translation The new translation data
     * @param {?} language
     * @param {?} translation
     * @return {?}
     */
    LocalizationService.prototype.addTranslation = function (language, translation) {
        // Adds the new translation data.
        this.addData(translation, language);
    };
    /**
     * Asynchronous loading: defines the translation provider.
    
    \@param prefix The path prefix of the json files
    \@param dataFormat Data format: default value is 'json'.
    \@param webAPI True if the asynchronous loading uses a Web API to get the data.
     * @param {?} prefix
     * @param {?=} dataFormat
     * @param {?=} webAPI
     * @return {?}
     */
    LocalizationService.prototype.translationProvider = function (prefix, dataFormat, webAPI) {
        if (dataFormat === void 0) { dataFormat = "json"; }
        if (webAPI === void 0) { webAPI = false; }
        this.addProvider(prefix, dataFormat, webAPI);
    };
    /**
     * Asynchronous loading: adds a translation provider.
    
    \@param prefix The path prefix of the json files
    \@param dataFormat Data format: default value is 'json'.
    \@param webAPI True if the asynchronous loading uses a Web API to get the data.
     * @param {?} prefix
     * @param {?=} dataFormat
     * @param {?=} webAPI
     * @return {?}
     */
    LocalizationService.prototype.addProvider = function (prefix, dataFormat, webAPI) {
        if (dataFormat === void 0) { dataFormat = "json"; }
        if (webAPI === void 0) { webAPI = false; }
        this.providers.push({ prefix: prefix, dataFormat: dataFormat, webAPI: webAPI });
        // Updates the loading mode.
        if (this.providers.length == 1) {
            this.loadingMode = LoadingMode.Async;
        }
    };
    /**
     * Translates a key.
    
    \@param key The key to be translated
    \@param args Parameters
    \@param lang The current language
    \@return The value of translation
     * @param {?} key
     * @param {?=} args
     * @param {?=} lang
     * @return {?}
     */
    LocalizationService.prototype.translate = function (key, args, lang) {
        if (lang === void 0) { lang = this.languageCode; }
        var /** @type {?} */ value;
        if (this.translationData[lang] != null) {
            // Gets the translation by language code. 
            var /** @type {?} */ translation = this.translationData[lang];
            // Checks for composed key (see issue #21).
            if (this.composedKey) {
                var /** @type {?} */ keys = key.split(this.keySeparator);
                do {
                    key = keys.shift();
                    if (translation[key] != null && (typeof translation[key] == "object")) {
                        translation = translation[key];
                    }
                } while (keys.length > 0);
            }
            // Gets the value of translation by key.   
            value = translation[key];
        }
        // Handles missing keys (see issues #1 & #31).
        if (value == null || value == "") {
            if (this.missingKey) {
                return this.translate(this.missingKey, args, lang);
            }
            else if (this.missingValue) {
                return this.missingValue;
            }
            return key; // The same key is returned.
        }
        else if (args != null) {
            var /** @type {?} */ TEMPLATE_REGEXP = /{{\s?([^{}\s]*)\s?}}/g;
            return value.replace(TEMPLATE_REGEXP, function (substring, parsedKey) {
                var /** @type {?} */ response = (args[parsedKey]);
                return (typeof response !== 'undefined') ? response : substring;
            });
        }
        return value;
    };
    /**
     * Translates a key.
    
    \@param key The key to be translated
    \@param args Parameters
    \@param lang The current language
    \@return An observable of the value of translation
     * @param {?} key
     * @param {?=} args
     * @param {?=} lang
     * @return {?}
     */
    LocalizationService.prototype.translateAsync = function (key, args, lang) {
        var _this = this;
        if (lang === void 0) { lang = this.languageCode; }
        return Observable.create(function (observer) {
            // Gets the value of translation for the key.
            var /** @type {?} */ value = _this.translate(key, args, lang);
            observer.next(value);
            observer.complete();
        });
    };
    /**
     * Sets the use of locale as language for the service (see issue #24).
     * @return {?}
     */
    LocalizationService.prototype.useLocaleAsLanguage = function () {
        this.enableLocale = true;
    };
    /**
     * Gets language code and loads the translation data for the asynchronous loading.
    
    \@param language The language for the service
     * @param {?=} language
     * @return {?}
     */
    LocalizationService.prototype.updateTranslation = function (language) {
        if (language === void 0) { language = !this.enableLocale
            ? this.locale.getCurrentLanguage()
            : this.locale.getCurrentLanguage()
                + "-"
                + this.locale.getCurrentCountry(); }
        if (language != "" && language != this.languageCode) {
            // Asynchronous loading.
            if (this.loadingMode == LoadingMode.Async) {
                // Updates the translation data.  
                this.getTranslation(language);
            }
            else {
                this.translationComplete(language);
            }
        }
    };
    /**
     * Sets the value to use for missing keys.
    
    \@param value The value to use for missing keys
     * @param {?} value
     * @return {?}
     */
    LocalizationService.prototype.setMissingValue = function (value) {
        this.missingValue = value;
    };
    /**
     * Sets the key to use for missing keys.
    
    \@param key The key to use for missing keys
     * @param {?} key
     * @return {?}
     */
    LocalizationService.prototype.setMissingKey = function (key) {
        this.missingKey = key;
    };
    /**
     * Sets composed key option.
    
    \@param composedKey False to disable composed key. Default is true
    \@param keySeparator Composed key separator. Default is the point '.'
     * @param {?=} composedKey
     * @param {?=} keySeparator
     * @return {?}
     */
    LocalizationService.prototype.setComposedKey = function (composedKey, keySeparator) {
        this.composedKey = composedKey;
        this.keySeparator = keySeparator;
    };
    /**
     * Compares two keys by the value of translation & the current language code.
    
    \@param key1, key2 The keys of the values to compare
    \@param extension
    \@param options
    \@return A negative value if the value of translation of key1 comes before the value of translation of key2; a positive value if key1 comes after key2; 0 if they are considered equal or Intl.Collator is not supported
    \@see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Collator
     * @param {?} key1
     * @param {?} key2
     * @param {?=} extension
     * @param {?=} options
     * @return {?}
     */
    LocalizationService.prototype.compare = function (key1, key2, extension, options) {
        // Checks for support for Intl.
        if (IntlSupport.Collator(this.locale.getCurrentLanguage()) == false) {
            return 0;
        }
        // Gets the value of translation for the keys.
        var /** @type {?} */ value1 = this.translate(key1);
        var /** @type {?} */ value2 = this.translate(key2);
        var /** @type {?} */ locale = this.addExtension(this.locale.getCurrentLanguage(), extension);
        return new Intl.Collator(locale).compare(value1, value2);
    };
    /**
     * Sorts an array of objects or an array of arrays by the current language code.
    
    \@param list The array to be sorted
    \@param keyName The column that contains the keys of the values to be ordered
    \@param order 'asc' or 'desc'. The default value is 'asc'.
    \@param extension
    \@param options
    \@return The same sorted list or the same list if Intl.Collator is not supported
    \@see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Collator
     * @param {?} list
     * @param {?} keyName
     * @param {?=} order
     * @param {?=} extension
     * @param {?=} options
     * @return {?}
     */
    LocalizationService.prototype.sort = function (list, keyName, order, extension, options) {
        if (list == null || keyName == null || IntlSupport.Collator(this.locale.getCurrentLanguage()) == false) {
            return list;
        }
        // Gets the value of translation for the keys.
        for (var _i = 0, list_1 = list; _i < list_1.length; _i++) {
            var item = list_1[_i];
            // Gets the value of translation for the key.
            var /** @type {?} */ value = this.translate(item[keyName]);
            // Adds a new column for translated values.
            var /** @type {?} */ translated = keyName.concat("Translated");
            // Updates the value in the list.
            item[translated] = value;
        }
        var /** @type {?} */ locale = this.addExtension(this.locale.getCurrentLanguage(), extension);
        // Intl.Collator.
        var /** @type {?} */ collator = new Intl.Collator(locale, options); // It can be passed directly to Array.prototype.sort.
        list.sort(function (a, b) {
            return collator.compare(a[translated], b[translated]);
        });
        // Removes the column of translated values.
        var /** @type {?} */ index = list.indexOf(translated, 0);
        if (index > -1) {
            list.splice(index, 1);
        }
        // Descending order.
        if (order != null && order == "desc") {
            list.reverse();
        }
        return list;
    };
    /**
     * Sorts an array of objects or an array of arrays by the current language code.
    
    \@param list The array to be sorted
    \@param keyName The column that contains the keys of the values to be ordered
    \@param order 'asc' or 'desc'. The default value is 'asc'.
    \@param extension
    \@param options
    \@return An observable of the sorted list or of the same list if Intl.Collator is not supported
    \@see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Collator
     * @param {?} list
     * @param {?} keyName
     * @param {?=} order
     * @param {?=} extension
     * @param {?=} options
     * @return {?}
     */
    LocalizationService.prototype.sortAsync = function (list, keyName, order, extension, options) {
        var _this = this;
        return Observable.create(function (observer) {
            // Gets the sorted list.
            observer.next(_this.sort(list, keyName, order, extension, options));
            observer.complete();
        });
    };
    /**
     * Matches a string into an array of objects or an array of arrays.
    
    \@param s The string to search
    \@param list The array to look for
    \@param keyNames An array that contains the columns to look for
    \@param options
    \@return A filtered list or the same list if Intl.Collator is not supported
    \@see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Collator
     * @param {?} s
     * @param {?} list
     * @param {?} keyNames
     * @param {?=} options
     * @return {?}
     */
    LocalizationService.prototype.search = function (s, list, keyNames, options) {
        var _this = this;
        if (options === void 0) { options = { usage: 'search' }; }
        if (list == null || keyNames == null || s == "" || IntlSupport.Collator(this.locale.getCurrentLanguage()) == false) {
            return list;
        }
        // Gets the value of translation for the each column.
        var /** @type {?} */ translated = new Array();
        var /** @type {?} */ i = 0;
        for (var /** @type {?} */ i = 0; i < keyNames.length; i++) {
            // Adds a new column for translated values.
            translated.push(keyNames[i].concat("Translated"));
            for (var _i = 0, list_2 = list; _i < list_2.length; _i++) {
                var item = list_2[_i];
                // Gets the values of translation for the column.
                var /** @type {?} */ value = this.translate(item[keyNames[i]]);
                // Updates the value in the list.
                item[translated[i]] = value;
            }
        }
        var /** @type {?} */ locale = this.locale.getCurrentLanguage();
        // Intl.Collator.
        var /** @type {?} */ collator = new Intl.Collator(locale, options);
        var /** @type {?} */ matches = list.filter(function (v) {
            var /** @type {?} */ found = false;
            for (var /** @type {?} */ i = 0; i < translated.length; i++) {
                // Calls matching algorithm.
                if (_this.match(v[translated[i]], s, collator)) {
                    found = true;
                    break;
                }
            }
            return found;
        });
        // Removes the columns of translated values.
        for (var /** @type {?} */ i = 0; i < translated.length; i++) {
            var /** @type {?} */ index = matches.indexOf(translated[i], 0);
            if (index > -1) {
                matches.splice(index, 1);
            }
        }
        return matches;
    };
    /**
     * Matches a string into an array of objects or an array of arrays.
    
    \@param s The string to search
    \@param list The array to look for
    \@param keyNames An array that contains the columns to look for
    \@param options
    \@return An observable for each element of the filtered list or the same list if Intl.Collator is not supported
    \@see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Collator
     * @param {?} s
     * @param {?} list
     * @param {?} keyNames
     * @param {?=} options
     * @return {?}
     */
    LocalizationService.prototype.searchAsync = function (s, list, keyNames, options) {
        var _this = this;
        if (options === void 0) { options = { usage: 'search' }; }
        if (list == null) {
            return null;
        }
        if (keyNames == null || s == "" || IntlSupport.Collator(this.locale.getCurrentLanguage()) == false) {
            return Observable.create(function (observer) {
                for (var _i = 0, list_3 = list; _i < list_3.length; _i++) {
                    var item = list_3[_i];
                    observer.next(item);
                }
                observer.complete();
            });
        }
        return Observable.create(function (observer) {
            // Gets the value of translation for the each column.
            var /** @type {?} */ translated = new Array();
            var /** @type {?} */ i = 0;
            for (var /** @type {?} */ i = 0; i < keyNames.length; i++) {
                // Adds a new column for translated values.
                translated.push(keyNames[i].concat("Translated"));
                for (var _i = 0, list_4 = list; _i < list_4.length; _i++) {
                    var item = list_4[_i];
                    // Gets the values of translation for the column.
                    var /** @type {?} */ value = _this.translate(item[keyNames[i]]);
                    // Updates the value in the list.
                    item[translated[i]] = value;
                }
            }
            var /** @type {?} */ locale = _this.locale.getCurrentLanguage();
            // Intl.Collator.
            var /** @type {?} */ collator = new Intl.Collator(locale, options);
            for (var _a = 0, list_5 = list; _a < list_5.length; _a++) {
                var v = list_5[_a];
                for (var /** @type {?} */ i = 0; i < translated.length; i++) {
                    // Calls matching algorithm.
                    if (_this.match(v[translated[i]], s, collator)) {
                        observer.next(v);
                        break;
                    }
                }
            }
            // Removes the columns of translated values.
            for (var /** @type {?} */ i = 0; i < translated.length; i++) {
                var /** @type {?} */ index = list.indexOf(translated[i], 0);
                if (index > -1) {
                    list.splice(index, 1);
                }
            }
            observer.complete();
        });
    };
    /**
     * @param {?} locale
     * @param {?=} extension
     * @return {?}
     */
    LocalizationService.prototype.addExtension = function (locale, extension) {
        // Adds extension.
        if (extension != null && extension != "") {
            locale = locale + "-" + extension;
        }
        return locale;
    };
    /**
     * Matching algorithm.
    
    \@param v The value
    \@param s The string to search
    \@return True if match, otherwise false
     * @param {?} v
     * @param {?} s
     * @param {?} collator
     * @return {?}
     */
    LocalizationService.prototype.match = function (v, s, collator) {
        var /** @type {?} */ vLength = v.length;
        var /** @type {?} */ sLength = s.length;
        if (sLength > vLength) {
            return false;
        } // The search string is longer than value.
        if (sLength == vLength) {
            return collator.compare(v, s) === 0;
        }
        // Tries to search the substring.
        var /** @type {?} */ found = false;
        for (var /** @type {?} */ i = 0; i < vLength - (sLength - 1); i++) {
            var /** @type {?} */ str = v.substr(i, sLength);
            if (collator.compare(str, s) === 0) {
                found = true;
                break;
            }
        }
        return found;
    };
    /**
     * Asynchronous loading: gets translation data.
     * @param {?} language
     * @return {?}
     */
    LocalizationService.prototype.getTranslation = function (language) {
        var _this = this;
        // Initializes the translation data & the service state.
        this.translationData = {};
        this.serviceState = ServiceState.isLoading;
        var /** @type {?} */ observableSequencesOfTranslationData = [];
        for (var _i = 0, _a = this.providers; _i < _a.length; _i++) {
            var provider = _a[_i];
            // Builds the URL.
            var /** @type {?} */ url = provider.prefix;
            if (provider.webAPI == true) {
                // Absolute URL for Web API.
                url += language;
            }
            else {
                // Relative server path for 'json' files.
                url += language + "." + provider.dataFormat;
            }
            observableSequencesOfTranslationData.push(this.getTranslationByProvider(url));
        }
        // Merges all the observable sequences into a single observable sequence.
        Observable.merge.apply(Observable, observableSequencesOfTranslationData).subscribe(
        // Next.
        function (data) {
            // Adds response to the translation data.
            _this.addData(data, language);
        }, 
        // Error.
        function (error) {
            console.error("Localization service:", error);
        }, 
        // Complete.
        function () {
            _this.translationComplete(language);
        });
    };
    /**
     * @param {?} url
     * @return {?}
     */
    LocalizationService.prototype.getTranslationByProvider = function (url) {
        return this.http.get(url)
            .map(function (res) { return res.json(); });
    };
    /**
     * Adds or extends translation data.
     * @param {?} data
     * @param {?} language
     * @return {?}
     */
    LocalizationService.prototype.addData = function (data, language) {
        this.translationData[language] = (typeof this.translationData[language] != "undefined") ? this.extend(this.translationData[language], data) : data;
    };
    /**
     * Merges objects.
     * @param {...?} args
     * @return {?}
     */
    LocalizationService.prototype.extend = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
        }
        var /** @type {?} */ newObj = {};
        for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
            var obj = args_1[_a];
            for (var key in obj) {
                // Copies all the fields.
                newObj[key] = obj[key];
            }
        }
        return newObj;
    };
    /**
     * @param {?} language
     * @return {?}
     */
    LocalizationService.prototype.translationComplete = function (language) {
        // Updates the service state.
        this.serviceState = ServiceState.isReady;
        // Updates the language code of the service: all the translate pipe will invoke the trasform method.
        this.languageCode = language;
        // Sends an event for the components.
        this.translationChanged.emit(language);
    };
    LocalizationService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    LocalizationService.ctorParameters = function () { return [
        { type: Http, },
        { type: LocaleService, },
    ]; };
    LocalizationService.propDecorators = {
        'translationChanged': [{ type: Output },],
    };
    return LocalizationService;
}());
function LocalizationService_tsickle_Closure_declarations() {
    /** @type {?} */
    LocalizationService.decorators;
    /**
     * @nocollapse
     * @type {?}
     */
    LocalizationService.ctorParameters;
    /** @type {?} */
    LocalizationService.propDecorators;
    /**
     * Output for event translation changed.
     * @type {?}
     */
    LocalizationService.prototype.translationChanged;
    /**
     * The language code for the service.
     * @type {?}
     */
    LocalizationService.prototype.languageCode;
    /**
     * The loading mode for the service.
     * @type {?}
     */
    LocalizationService.prototype.loadingMode;
    /**
     * The service state.
     * @type {?}
     */
    LocalizationService.prototype.serviceState;
    /**
     * Enable/disable locale as language.
     * @type {?}
     */
    LocalizationService.prototype.enableLocale;
    /**
     * The providers for the asynchronous loading.
     * @type {?}
     */
    LocalizationService.prototype.providers;
    /**
     * The translation data: {languageCode: {key: value}}.
     * @type {?}
     */
    LocalizationService.prototype.translationData;
    /**
     * Value for missing keys.
     * @type {?}
     */
    LocalizationService.prototype.missingValue;
    /**
     * Key for missing keys.
     * @type {?}
     */
    LocalizationService.prototype.missingKey;
    /**
     * Option for composed key.
     * @type {?}
     */
    LocalizationService.prototype.composedKey;
    /**
     * Separator for composed key.
     * @type {?}
     */
    LocalizationService.prototype.keySeparator;
    /** @type {?} */
    LocalizationService.prototype.http;
    /** @type {?} */
    LocalizationService.prototype.locale;
}
/**
 * Defines the provider for asynchronous loading of the translation data.
 */
var Provider = (function () {
    function Provider() {
    }
    return Provider;
}());
function Provider_tsickle_Closure_declarations() {
    /** @type {?} */
    Provider.prototype.prefix;
    /** @type {?} */
    Provider.prototype.dataFormat;
    /** @type {?} */
    Provider.prototype.webAPI;
}
export var ServiceState = {};
ServiceState.isReady = 0;
ServiceState.isLoading = 1;
ServiceState.isWaiting = 2;
ServiceState[ServiceState.isReady] = "isReady";
ServiceState[ServiceState.isLoading] = "isLoading";
ServiceState[ServiceState.isWaiting] = "isWaiting";
export var LoadingMode = {};
LoadingMode.Direct = 0;
LoadingMode.Async = 1;
LoadingMode[LoadingMode.Direct] = "Direct";
LoadingMode[LoadingMode.Async] = "Async";
//# sourceMappingURL=localization.service.js.map