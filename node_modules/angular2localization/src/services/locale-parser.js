/**
 * ANGULAR 2 LOCALIZATION
 * An Angular 2 library to translate messages, dates and numbers.
 * Written by Roberto Simonetti.
 * MIT license.
 * https://github.com/robisim74/angular2localization
 */
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
import { IntlSupport } from './Intl-support';
/**
 * @param {?} obj
 * @return {?}
 */
export function isPresent(obj) {
    return obj !== undefined && obj !== null;
}
/**
 * LocaleParser class.
Parses a string and returns a number by default locale.

\@author Roberto Simonetti
 */
export var LocaleParser = (function () {
    function LocaleParser() {
    }
    /**
     * Builds the regular expression for a number by default locale.
    
    \@param defaultLocale The default locale
    \@param digits The digit info: {minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}
    \@return A RegExp object
     * @param {?} defaultLocale
     * @param {?} digits
     * @return {?}
     */
    LocaleParser.NumberRegExpFactory = function (defaultLocale, digits) {
        // Gets digits.
        var /** @type {?} */ minInt = 1;
        var /** @type {?} */ minFraction = 0;
        var /** @type {?} */ maxFraction = 3;
        var /** @type {?} */ NUMBER_FORMAT_REGEXP = /^(\d+)?\.((\d+)(\-(\d+))?)?$/;
        if (isPresent(digits)) {
            var /** @type {?} */ parts = digits.match(NUMBER_FORMAT_REGEXP);
            if (parts === null) {
                throw new Error(digits + " is not a valid digit info for number");
            }
            if (isPresent(parts[1])) {
                minInt = NumberWrapper.parseIntAutoRadix(parts[1]);
            }
            if (isPresent(parts[3])) {
                minFraction = NumberWrapper.parseIntAutoRadix(parts[3]);
            }
            if (isPresent(parts[5])) {
                maxFraction = NumberWrapper.parseIntAutoRadix(parts[5]);
            }
        }
        // Converts numbers & signs to Unicode by default locale.
        var /** @type {?} */ codes = new DecimalCode(defaultLocale);
        var /** @type {?} */ minusSign = codes.minusSign;
        var /** @type {?} */ zero = codes.numbers[0];
        var /** @type {?} */ decimalSeparator = codes.decimalSeparator;
        var /** @type {?} */ nine = codes.numbers[9];
        // Pattern for 1.2-2 digits: /^-?[0-9]{1,}\.[0-9]{2,2}$/
        // Unicode pattern = "^\u002d?[\u0030-\u0039]{1,}\\u002e[\u0030-\u0039]{2,2}$";
        var /** @type {?} */ pattern;
        if (minFraction > 0 && maxFraction > 0) {
            pattern = "^"
                + minusSign
                + "?[" + zero + "-" + nine
                + "]{" + minInt + ",}\\"
                + decimalSeparator
                + "[" + zero + "-" + nine
                + "]{" + minFraction + "," + maxFraction
                + "}$";
        }
        else if (minFraction == 0 && maxFraction > 0) {
            // Decimal separator is optional.
            pattern = "^"
                + minusSign
                + "?[" + zero + "-" + nine
                + "]{" + minInt + ",}\\"
                + decimalSeparator
                + "?[" + zero + "-" + nine
                + "]{" + minFraction + "," + maxFraction
                + "}$";
        }
        else {
            // Integer number.
            pattern = "^"
                + minusSign
                + "?[" + zero + "-" + nine
                + "]{" + minInt + ",}$";
        }
        pattern = codes.UnicodeToChar(pattern);
        var /** @type {?} */ regExp = new RegExp(pattern);
        return regExp;
        // Wonderful, it works!
    };
    /**
     * Parses a string and returns a number by default locale.
    
    \@param s The string to be parsed
    \@param defaultLocale The default locale
    \@return A number. If the string cannot be converted to a number, returns NaN
     * @param {?} s
     * @param {?} defaultLocale
     * @return {?}
     */
    LocaleParser.Number = function (s, defaultLocale) {
        if (s == "" || defaultLocale == "" || defaultLocale == null) {
            return null;
        }
        var /** @type {?} */ codes = new DecimalCode(defaultLocale);
        return codes.parse(s);
    };
    return LocaleParser;
}());
/**
 * NumberCode abstract superclass.

Converts numbers to Unicode by locales.

\@author Roberto Simonetti
 * @abstract
 */
export var NumberCode = (function () {
    /**
     * @param {?} defaultLocale
     */
    function NumberCode(defaultLocale) {
        this.defaultLocale = defaultLocale;
        this.numbers = [];
        for (var i = 0; i <= 9; i++) {
            this.numbers.push(this.Unicode(i.toString()));
        }
        // Checks for support for Intl.
        if (IntlSupport.NumberFormat(defaultLocale) == true) {
            // Updates Unicode for numbers by default locale.
            for (var i = 0; i <= 9; i++) {
                this.numbers[i] = this.Unicode(new Intl.NumberFormat(defaultLocale).format(i));
            }
        }
    }
    /**
     * Parses a string and returns a number by default locale.
    
    \@param s The string to be parsed
    \@return A number
     * @abstract
     * @param {?} s
     * @return {?}
     */
    NumberCode.prototype.parse = function (s) { };
    /**
     * @abstract
     * @param {?} pattern
     * @return {?}
     */
    NumberCode.prototype.UnicodeToChar = function (pattern) { };
    /**
     * @param {?} c
     * @return {?}
     */
    NumberCode.prototype.Unicode = function (c) {
        return "\\u" + this.HexEncode(c.charCodeAt(0));
    };
    /**
     * @param {?} value
     * @return {?}
     */
    NumberCode.prototype.HexEncode = function (value) {
        var /** @type {?} */ hex = value.toString(16).toUpperCase();
        // With padding.
        hex = "0000".substr(0, 4 - hex.length) + hex;
        return hex;
    };
    return NumberCode;
}());
function NumberCode_tsickle_Closure_declarations() {
    /**
     * Unicode for numbers from 0 to 9.
     * @type {?}
     */
    NumberCode.prototype.numbers;
    /** @type {?} */
    NumberCode.prototype.defaultLocale;
}
/**
 * DecimalCode class.

Converts numbers & signs to Unicode by locales.

\@author Roberto Simonetti
 */
var DecimalCode = (function (_super) {
    __extends(DecimalCode, _super);
    /**
     * @param {?} defaultLocale
     */
    function DecimalCode(defaultLocale) {
        _super.call(this, defaultLocale);
        this.defaultLocale = defaultLocale;
        this.minusSign = this.Unicode("-");
        this.decimalSeparator = this.Unicode(".");
        // Checks for support for Intl.
        if (IntlSupport.NumberFormat(defaultLocale) == true) {
            // Updates Unicode for signs by default locale.
            var value = -0.9; // Reference value.
            var localeValue = new Intl.NumberFormat(defaultLocale).format(value);
            // Checks Unicode character 'RIGHT-TO-LEFT MARK' (U+200F).
            if (this.Unicode(localeValue.charAt(0)) == "\\u200F") {
                // Right to left.
                this.minusSign = this.Unicode(localeValue.charAt(1));
                this.decimalSeparator = this.Unicode(localeValue.charAt(3));
            }
            else if (this.Unicode(localeValue.charAt(0)) == this.Unicode(new Intl.NumberFormat(defaultLocale).format(0))) {
                // IE & Edge reverse the order.
                this.minusSign = this.Unicode(localeValue.charAt(3));
                this.decimalSeparator = this.Unicode(localeValue.charAt(1));
            }
            else {
                // Left to right.
                this.minusSign = this.Unicode(localeValue.charAt(0));
                this.decimalSeparator = this.Unicode(localeValue.charAt(2));
            }
        }
    }
    /**
     * @param {?} s
     * @return {?}
     */
    DecimalCode.prototype.parse = function (s) {
        // Splits the String object into an array of characters.
        var /** @type {?} */ characters = s.split("");
        // Builds the value.
        var /** @type {?} */ value = "";
        for (var _i = 0, characters_1 = characters; _i < characters_1.length; _i++) {
            var char = characters_1[_i];
            var /** @type {?} */ charCode = this.Unicode(char);
            // Tries to look for the char code in numbers and signs.
            var /** @type {?} */ index = this.numbers.indexOf(charCode);
            if (index != -1) {
                value += index;
            }
            else if (charCode == this.minusSign) {
                value += "-";
            }
            else if (charCode == this.decimalSeparator) {
                value += ".";
            }
            else {
                return NaN;
            }
        }
        return parseFloat(value);
    };
    /**
     * @param {?} pattern
     * @return {?}
     */
    DecimalCode.prototype.UnicodeToChar = function (pattern) {
        return pattern.replace(/\\u[\dA-F]{4}/gi, function (match) {
            return String.fromCharCode(parseInt(match.replace(/\\u/g, ""), 16));
        });
    };
    return DecimalCode;
}(NumberCode));
function DecimalCode_tsickle_Closure_declarations() {
    /**
     * Unicode for minus sign.
     * @type {?}
     */
    DecimalCode.prototype.minusSign;
    /**
     * Unicode for decimal separator.
     * @type {?}
     */
    DecimalCode.prototype.decimalSeparator;
    /** @type {?} */
    DecimalCode.prototype.defaultLocale;
}
var NumberWrapper = (function () {
    function NumberWrapper() {
    }
    /**
     * @param {?} text
     * @return {?}
     */
    NumberWrapper.parseIntAutoRadix = function (text) {
        var /** @type {?} */ result = parseInt(text, null);
        if (isNaN(result)) {
            throw new Error('Invalid integer literal when parsing ' + text);
        }
        return result;
    };
    /**
     * @param {?} text
     * @param {?} radix
     * @return {?}
     */
    NumberWrapper.parseInt = function (text, radix) {
        if (radix == 10) {
            if (/^(\-|\+)?[0-9]+$/.test(text)) {
                return parseInt(text, radix);
            }
        }
        else if (radix == 16) {
            if (/^(\-|\+)?[0-9ABCDEFabcdef]+$/.test(text)) {
                return parseInt(text, radix);
            }
        }
        else {
            var /** @type {?} */ result = parseInt(text, radix);
            if (!isNaN(result)) {
                return result;
            }
        }
        throw new Error('Invalid integer literal when parsing ' + text + ' in base ' + radix);
    };
    return NumberWrapper;
}());
//# sourceMappingURL=locale-parser.js.map